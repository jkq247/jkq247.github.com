<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Jkq&#39;s Blog : " />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Jkq&#39;s Blog</title>
  </head>

  <body bgpropertities="fixed">
    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/jkq247">View on GitHub</a>

          <h1 id="project_title">Jkq&#39;s Blog</h1>
          <h2 id="project_tagline"></h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>Nginx匹配规则</h1>

        <p>基本规则如下:    </p>

        <ol>
        <li>= 前缀的指令严格匹配这个查询。如果找到，停止搜索。</li>
        <li>剩下的常规字符串，最长的匹配优先使用。如果这个匹配使用 ^~ 前缀，搜索停止。</li>
        <li>正则表达式，按配置文件里的顺序，第一个匹配的被使用。</li>
        <li>如果第三步产生匹配，则使用这个结果。否则使用第二步的匹配结果。</li>
        </ol>

        <p>在location中可以使用常规字符串和正则表达式。 <br />
        如果使用正则表达式，你必须使用以下规则： </p>

        <ol>
        <li>~* 前缀选择不区分大小写的匹配</li>
        <li>~  选择区分大小写的匹配</li>
        </ol>

        <p>例子：  </p>

        <pre><code>location = / {  
    # 只匹配 / 查询。  
    [ configuration A ]  
}  
location / {   
    # 匹配任何查询，因为所有请求都以 / 开头。  
    # 但是正则表达式规则和长的块规则将被优先和查询匹配。  
    [ configuration B ]
}  
location ^~ /images/ {  
    # 匹配任何以 /images/ 开头的任何查询并且停止搜索。  
    # 任何正则表达式将不会被测试。  
    [ configuration C ]  
}  
location ~* \.(gif|jpg|jpeg)$ {  
    # 匹配任何以 gif、jpg 或 jpeg 结尾的请求。  
    # 然而所有 /images/ 目录的请求将使用 Configuration C。  
    [ configuration D ]   
}  
        </code></pre>
     </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
